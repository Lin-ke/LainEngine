#pragma once
{{#class_defines}}
#ifndef REFLECTION_{{#class_is_in_class}}{{class_father_namespace}}{{/class_is_in_class}}{{class_name}}_H
#define REFLECTION_{{#class_is_in_class}}{{class_father_namespace}}{{/class_is_in_class}}{{class_name}}_H
{{/class_defines}}
{{#include_headfiles}}

#include "{{headfile_name}}"
#include "core/os/memory.h"
#include "core/string/ustring.h"

{{/include_headfiles}}

namespace lain{
    {{#class_defines}}{{^class_is_struct}}class{{/class_is_struct}}{{#class_is_struct}}struct{{/class_is_struct}} {{class_name}};
    {{/class_defines}}
namespace Reflection{
    {{#class_defines}}
    {{#vector_exist}}namespace ArrayReflectionOperator{
{{#vector_defines}}#ifndef Array{{vector_useful_name}}OperatorMACRO
#define Array{{vector_useful_name}}OperatorMACRO
    class Array{{vector_useful_name}}Operator{
        public:
            static const char* getArrayTypeName(){ return "{{{vector_type_name}}}";}
            static const char* getElementTypeName(){ return "{{{vector_element_type_name}}}";}
            static int getSize(void* instance){
                //todo: should check validation
                {{^vector_is_fixed_array}}
                return static_cast<int>(static_cast<{{{vector_type_name}}}*>(instance)->size());
                {{/vector_is_fixed_array}}
                 {{#vector_is_fixed_array}}
                return {{vector_fixed_size}};
                {{/vector_is_fixed_array}}
            }
            static void* get(int index,void* instance){
                //todo: should check validation
                 {{^vector_is_fixed_array}}
                return static_cast<void*>(&((*static_cast<{{{vector_type_name}}}*>(instance)){{#vector_is_cow_vector}}.write{{/vector_is_cow_vector}}[index]));
                {{/vector_is_fixed_array}}
                 {{#vector_is_fixed_array}}
               return static_cast<void*>(({{vector_element_type_name}}*)(instance) + index);
                {{/vector_is_fixed_array}}
                
            }
            static void set(int index, void* instance, void* element_value){
                //todo: should check validation
                 {{^vector_is_fixed_array}}
                (*static_cast<{{{vector_type_name}}}*>(instance)){{#vector_is_cow_vector}}.write{{/vector_is_cow_vector}}[index] = *static_cast<{{{vector_element_type_name}}}*>(element_value);
                {{/vector_is_fixed_array}}
                {{#vector_is_fixed_array}}
                *(({{vector_element_type_name}}*)(instance) + index) = *static_cast<{{{vector_element_type_name}}}*>(element_value);
                {{/vector_is_fixed_array}}
            
            }
    };
#endif //Array{{vector_useful_name}}Operator
{{/vector_defines}}
}//namespace ArrayReflectionOperator{{/vector_exist}}

namespace TypeFieldReflectionOperator{
    class Type{{#class_is_in_class}}{{class_father_namespace}}{{/class_is_in_class}}{{class_name}}Operator{
    public:
        static const char* getClassName(){ return "{{class_with_namespace}}";}
	static size_t get_size_of(){ return sizeof({{class_with_namespace}});}
	static void* memnew_class(void* target=nullptr) {
	if(target!=nullptr){memnew_placement(target, {{class_with_namespace}}); return target;}
	return memnew({{class_with_namespace}});
	}
	static void* memnew_class_arr(int size_of_arr) {return memnew_arr({{class_with_namespace}},size_of_arr);}

        static void* constructorWithJson(const Json& json_context){
            {{class_with_namespace}}* ret_instance= memnew({{class_with_namespace}});
            Serializer::read(json_context, *ret_instance);
            return ret_instance;
        }
        static Json writeByName(void* instance){
            return Serializer::write(*({{class_with_namespace}}*)instance);
        }
	static void json_read_warpper(const Json& json, void* instance) {
       Serializer::read(json, *reinterpret_cast<{{class_with_namespace}}*>(instance));  
	}
        // base class
        static int get{{class_name}}BaseClassReflectionInstanceList(ReflectionInstance* &out_list, void* instance){
            int count = {{class_base_class_size}};
            {{#class_has_base}}out_list = memnew(ReflectionInstance[count]);
            for (int i=0;i<count;++i){
            {{#class_base_class_defines}}
               out_list[i] = TypeMetaDef({{class_base_class_name}},static_cast<{{class_with_namespace}}*>(instance)); 
            {{/class_base_class_defines}}
            }{{/class_has_base}}
            return count;
        }
        // fields
        {{#class_field_defines}}static const char* getFieldName_{{class_field_name}}(){ return "{{class_field_name}}";}
        static const char* getFieldTypeName_{{class_field_name}}(){ return "{{{class_field_type}}}";}
        static void set_{{class_field_name}}(void* instance, void* field_value){ 
            {{^class_field_is_fixed_array}}
            static_cast<{{class_with_namespace}}*>(instance)->{{class_field_name}} = *static_cast<{{{class_field_type}}}*>(field_value);
            {{/class_field_is_fixed_array}}
            {{#class_field_is_fixed_array}}
            {{class_field_array_base_type}}* p_temp_array = ({{class_field_array_base_type}}*)static_cast<{{class_with_namespace}}*>(instance)->{{class_field_name}};
            {{class_field_array_base_type}}* p_field_value = ({{class_field_array_base_type}}*)(field_value);
            for (int i = 0; i < ArrayReflectionOperator::Array{{class_field_array_useful_name}}Operator::getSize(p_temp_array); i++) {
                ArrayReflectionOperator::Array{{class_field_array_useful_name}}Operator::set(i, p_temp_array, (void*)(&p_field_value[i]));
            }
            {{/class_field_is_fixed_array}}
            }
        static void* get_{{class_field_name}}(void* instance){ return static_cast<void*>(&(static_cast<{{class_with_namespace}}*>(instance)->{{class_field_name}}));}
        static bool isArray_{{class_field_name}}(){ {{#class_field_is_vector}}return true;{{/class_field_is_vector}}{{^class_field_is_vector}}return false;{{/class_field_is_vector}} }
        {{/class_field_defines}}

        // methods
        {{#class_method_defines}}
        static const char* getMethodName_{{class_method_name}}(){ return "{{class_method_name}}";}
        static void invoke_{{class_method_name}}(void * instance){static_cast<{{class_with_namespace}}*>(instance)->{{class_method_name}}();}
        {{/class_method_defines}}
    };
}//namespace TypeFieldReflectionOperator

    void TypeWrapperRegister_{{#class_is_in_class}}{{class_father_namespace}}{{/class_is_in_class}}{{class_name}}(){
        {{#class_field_defines}}FieldFunctionTuple* field_function_tuple_{{class_field_name}}=memnew(FieldFunctionTuple(
            &TypeFieldReflectionOperator::Type{{#class_is_in_class}}{{class_father_namespace}}{{/class_is_in_class}}{{class_name}}Operator::set_{{class_field_name}},
            &TypeFieldReflectionOperator::Type{{#class_is_in_class}}{{class_father_namespace}}{{/class_is_in_class}}{{class_name}}Operator::get_{{class_field_name}},
            &TypeFieldReflectionOperator::Type{{#class_is_in_class}}{{class_father_namespace}}{{/class_is_in_class}}{{class_name}}Operator::getClassName,
            &TypeFieldReflectionOperator::Type{{#class_is_in_class}}{{class_father_namespace}}{{/class_is_in_class}}{{class_name}}Operator::getFieldName_{{class_field_name}},
            &TypeFieldReflectionOperator::Type{{#class_is_in_class}}{{class_father_namespace}}{{/class_is_in_class}}{{class_name}}Operator::getFieldTypeName_{{class_field_name}},
            &TypeFieldReflectionOperator::Type{{#class_is_in_class}}{{class_father_namespace}}{{/class_is_in_class}}{{class_name}}Operator::isArray_{{class_field_name}}));
        REGISTER_FIELD_TO_MAP("{{class_with_namespace}}", field_function_tuple_{{class_field_name}});
        {{/class_field_defines}}

        {{#class_method_defines}}
        MethodFunctionTuple* method_function_tuple_{{class_method_name}}=memnew(MethodFunctionTuple(
            &TypeFieldReflectionOperator::Type{{#class_is_in_class}}{{class_father_namespace}}{{/class_is_in_class}}{{class_name}}Operator::getMethodName_{{class_method_name}},
            &TypeFieldReflectionOperator::Type{{#class_is_in_class}}{{class_father_namespace}}{{/class_is_in_class}}{{class_name}}Operator::invoke_{{class_method_name}});
        REGISTER_Method_TO_MAP("{{class_with_namespace}}", method_function_tuple_{{class_method_name}}));
        {{/class_method_defines}}
        
        {{#vector_exist}}{{#vector_defines}}ArrayFunctionTuple* array_tuple_{{vector_useful_name}} = memnew(ArrayFunctionTuple(
            &ArrayReflectionOperator::Array{{vector_useful_name}}Operator::set,
            &ArrayReflectionOperator::Array{{vector_useful_name}}Operator::get,
            &ArrayReflectionOperator::Array{{vector_useful_name}}Operator::getSize,
            &ArrayReflectionOperator::Array{{vector_useful_name}}Operator::getArrayTypeName,
            &ArrayReflectionOperator::Array{{vector_useful_name}}Operator::getElementTypeName));
        REGISTER_ARRAY_TO_MAP("{{{vector_type_name}}}", array_tuple_{{vector_useful_name}});
        {{/vector_defines}}{{/vector_exist}}
        {{#class_need_register}}ClassFunctionTuple* class_function_tuple_{{class_name}}=memnew(ClassFunctionTuple(
            &TypeFieldReflectionOperator::Type{{#class_is_in_class}}{{class_father_namespace}}{{/class_is_in_class}}{{class_name}}Operator::get{{class_name}}BaseClassReflectionInstanceList,
            &TypeFieldReflectionOperator::Type{{#class_is_in_class}}{{class_father_namespace}}{{/class_is_in_class}}{{class_name}}Operator::constructorWithJson,
            &TypeFieldReflectionOperator::Type{{#class_is_in_class}}{{class_father_namespace}}{{/class_is_in_class}}{{class_name}}Operator::writeByName,
	&TypeFieldReflectionOperator::Type{{#class_is_in_class}}{{class_father_namespace}}{{/class_is_in_class}}{{class_name}}Operator::json_read_warpper,
	&TypeFieldReflectionOperator::Type{{#class_is_in_class}}{{class_father_namespace}}{{/class_is_in_class}}{{class_name}}Operator::memnew_class,
	&TypeFieldReflectionOperator::Type{{#class_is_in_class}}{{class_father_namespace}}{{/class_is_in_class}}{{class_name}}Operator::memnew_class_arr,
	&TypeFieldReflectionOperator::Type{{#class_is_in_class}}{{class_father_namespace}}{{/class_is_in_class}}{{class_name}}Operator::get_size_of));
        REGISTER_BASE_CLASS_TO_MAP("{{class_with_namespace}}", class_function_tuple_{{class_name}});
        {{/class_need_register}}
       
    }{{/class_defines}}
namespace TypeWrappersRegister{
    void {{sourefile_name_upper_camel_case}}()
    {
        {{#class_defines}}TypeWrapperRegister_{{#class_is_in_class}}{{class_father_namespace}}{{/class_is_in_class}}{{class_name}}();
    {{/class_defines}}
    }
}//namespace TypeWrappersRegister

}//namespace Reflection
}//namespace lain
{{#class_defines}}
#endif
{{/class_defines}}

